
\section{Τελεστής σταθερού σημείου}

Η προσθήκη αναδρομικών τύπων σε μία συναρτησιακή γλώσσα γίνεται με την χρήση του
\emph{τελεστή σταθερού σημείου} (fixpoint operator).  Ο τελεστής σταθερού σημείου
είναι μια συνάρτηση μεγαλύτερης τάξης (higher-order function), που βρίσκει υπολογιστικά
το σταθερό σημείο συναρτήσεων, αν αυτό υπάρχει και είναι καλός ορισμένο. Η παράσταση $\fixo f$
αντιστοιχεί στο $x$ για το οποίο ισχύει $x = f x$.  Η εξίσωση που ικανοποιεί ο τελεστής σταθερού σημείου
είναι η εξής:

\begin{displaymath}
\fixo f = f (\fixo f)
\end{displaymath}

Ο τελεστής σταθερού σημείου \texttt{fix} βρίσκει εφαρμογή σε διάφορους κλάδους των μαθηματικών, κυρίως
γύρω από τον τομέα της θεωρητικής επιστήμης υπολογιστών, του λ-λογισμού με ή χωρίς τύπους και στον
συναρτησιακό προγραμματισμό. Ο τελεστής \texttt{fix} παίρνει ως όρισμα μια μη αναδρομική συνάρτηση και
``δένει τον κόμπο" γύρω από τον εαυτό της ώστε να την μετατρέψει σε αναδρομική. Η χρήση του \texttt{fix} γίνεται εμφανής με το παρακάτω παράδειγμα:

\begin{align*}
 \texttt{fix} \ f &= f \ (\texttt{fix} \ f)   \\
\textbf{List} ~a &= \texttt{fix} (\lambda r . \Lambda a. 1 + a * r) \\
&= (\lambda r. \Lambda a. 1 + a * r) (\texttt{fix} (\lambda r. \Lambda a. 1 + a * r))  \\
&= \Lambda \alpha. 1 + a*(\texttt{fix} (\lambda r. \Lambda a. 1 + a * r)) \\
 &= \Lambda a. 1 + a * \textbf{List} ~a \\
 &= \cdots \\
&= \Lambda \alpha. 1+ a * \cdots * a \\
\end{align*}

Ως όρισμα στον τελεστή σταθερού σημείου δίνεται η συνάρτηση $(\lambda r. \Lambda 1 + a *r)$, και η
μεταβλητή $r$ αντιστοιχεί στην αναδρομική εμφάνιση ενός τύπου. Η εφαρμογή του \texttt{fix} στην συνάρτηση
αυτή γεννάει τον τελικό αναδρομικό τύπο. Τα fixpoints με τα οποία ασχολούμαστε στην γλώσσα μας ανήκουν στην κατηγορία των \emph{least fixpoint}, όπως και οι περισσότερες χρήσεις τελεστών σταθερών σημείων στην βιβλιογραφία.

\section{Isorecursive και equirecursive τύποι}
\label{sec:rectypes-intro}


Αρχικά καλούμαστε να επιλέξουμε ποια εκδοχή των αναδρομικών τύπων
θα υποστηρίξουμε.
Οι \emph{equirecursive} τύποι ταυτίζουν τον τύπο $(\fixo f)$ με τον $f (\fixo f)$ ενώ οι
\emph{isorecursive} τύποι τους θεωρούν ισομορφικούς. Ως μάρτυρες (witness) του ισομορφισμού
χρησιμοποιούνται οι όροι $\wrap$ και $\unwrap$ που συνοδεύουν  την μετατροπή από
την μία μορφή στην άλλη. Η ακριβής σύνταξη και χρήση των όρων αυτών συζητάται στο επόμενο
κεφάλαιο όπου παρουσιάζεται η σύνταξη και οι κανόνες της \FOMF{} και \FIR{}.

Το τίμημα είναι ότι ενώ οι equirecursive τύποι δεν προσθέτουν επιπλέον όρους στο επίπεδο
της γλώσσας, έχουν πιο περίπλοκη θεωρητική ανάλυση. Συγκεκριμένα, ο έλεγχος τύπων
στην \FOMF{} με equirecursive types έχει δειχθεί ότι είναι undecidable στην γενική περίπτωση
\cite{dreyer2007}, \cite{cai}. Η χρήση isorecursive τύπων στην γλώσσα μας κάνει την συγγραφή
προγραμμάτων πιο δύσκολη, αλλά δέχεται πιο εύκολη ανάλυση και οι κανόνες τύπων μπορούν
να εκφραστούν αρκετά απλά. Η γλώσσα που θα ορίσουμε έχει κύρια χρήση ως ενδιάμεση γλώσσα
επομένως δεν είναι κύριος στόχος η εύκολη σύνθεση από τον προγραμματιστή, γεγονός που
δικαιολογεί την επιλογή των isorecursive τύπων.

Ως παράδειγμα, βλέπουμε παρακάτω την έκφραση του ``κλασσικότερου" αναδρομικού
τύπου, της λίστας, στην γλώσσα της θεωρία τύπων, ακολουθώντας τον συμβολισμό του \cite{wadler:free-rectypes}. Βλέπουμε επίσης πως λειτουργούν οι όροι $\wrap$ και $\unwrap$ που παρουσιάζονται αναλυτικότερα
στο κεφάλαιο \ref{chap:chapter4}.

\begin{align*}
       &  \List = \mu \alpha. \tau = \mu \alpha. 1 + \alpha*\List \\
        % \mu X . int + int * X  = \mu X. \tau $
  &       \unwrap (\mu \alpha. \tau) = \tau\{\mu \alpha. \tau / \alpha\} =
         1 + \alpha * (\mu \alpha. \tau) \\
     &   \wrap ( 1 + \alpha * (\mu \alpha. \tau)) =
         \mu \alpha. \tau \\
\end{align*}


\section{Επιλογή του κατάλληλου τελεστή σταθερού σημείου}
\label{sec:fixpoint_choice}

Πρέπει ακόμα να επιλεχθεί ο κατάλληλος τελεστής σταθερού σημείου που θα χρησιμοποιήσουμε.
Μία κλασσική επιλογή είναι ο τελεστής  $\fixo$ που επιτρέπει να πάρουμε τα σταθερά σημεία
συναρτήσεων στο επίπεδο των τύπων, για όλα τα kinds $K$ ( $\fixo : (K \kindArrow K) \kindArrow Κ$).
Στην γλώσσα μας αντιθέτως, θα γίνει χρήση του τελεστή $\ifix$ (``indexed fix") που επιτρέπει
σταθερά σημεία μόνο σε kinds $K \kindArrow \Type$.

Το πλεονέκτημα του $\ifix$  είναι ότι διευκολύνει την διατύπωση κανόνων σύνθεσης τύπων, όπως φαίνεται
και από το παρακάτω παράδειγμα:

      \begin{displaymath}
      \begin{array}{l@{\ }l@{\ }l@{\ }l@{\ }l}
      \wrap_0 f_0            & t &: \fixo f_0 & \textrm{where} & t : f_0\ (\fixo f_0)\\
        \wrap_1 f_1  ~ a1      & t &: \fixo f_1\ a1 & \textrm{where} & t : f_1\ (\fixo f_1)\ a1\\
        \wrap_2 f_2  ~ a1 ~ a2 & t &: \fixo f_2\ a1\ a2 & \textrm{where} & t : f_2\ (\fixo f_2)\ a1\ a2\\
        \dots & & & &
        \end{array}
        \end{displaymath}

Με τη χρήση του κλασσικού τελεστή $\fixo$ πρέπει να είμαστε σε θέση να υποστηρίξουμε όλα τα
arities των συναρτήσεων τύπων που μπορούμε να εκφράσουμε, καθώς δεν υποστηρίζεται  πολυμορφισμός
στο επίπεδο των kinds. Οι όροι $\wrap$ και $\unwrap$ τελικά πρέπει να ανήκουν στο επίπεδο των όρων,
δηλαδή με kind $\Type$.

Είναι δυνατόν να δοθούν κανόνες τύπων συμβατοί με τον τελεστή \texttt{fix}, όπως έχει δειχθεί στο
\cite{dreyer2005}, κάνοντας χρήση της τεχνικής των \emph{elimination contexts}. Η προσέγγιση αυτή
λύνει το πρόβλημα που αναφέραμε, αλλά περιπλέκει αρκετά τους όρους καθώς χρειάζεται να
συνοδεύονται από επιπλέον πληροφορία και κάνει ακόμα πιο απαιτητική την σύνθεση τύπων.

Επομένως η χρήση του διαφορετικού τελεστή σταθερού σημείου που αναφέρθηκε απλοποιεί
τους κανόνες σύνθεσης τύπων, λειτουργεί ομοιόμορφα για όλες τις περιπτώσεις, δεχόμενος
μόνο ένα όρισμα με kind $k$, και επιστρέφει έναν όρο.

Ο τελεστής $\ifix$ έχει την ίδια εκφραστική δύναμη με τον \texttt{fix}, παρά την επιφανειακά περιορισμένη μορφή του. Στην επόμενη παράγραφο θα δούμε την απόδειξη της ισοδυναμίας εκφραστικότητας.


\subsection{Επάρκεια του $\ifix$}
        \label{subsec:adifix}

Ο τελεστής $\ifix$ είναι αρκετά εκφραστικός για να μας δώσει σταθερά σημεία συναρτήσεων
σε αυθαίρετα kinds $k$. Η διαίσθηση πίσω από την απόδειξη είναι ότι μπορούμε να μετασχηματίσουμε
κάθε kind $K$ στο $(K \kindArrow \Type) \kindArrow \Type$, που έχει την κατάλληλη μορφή για το $\ifix$.


        \newtheorem{definition}{Ορισμός}
        \begin{definition}
        Έστω $J, Κ$ kinds. Τότε ονομάζουμε το $J$ \emph{συμπύκνωση} του $K$ εάν υπάρχουν
        συναρτήσεις $\phi: J \kindArrow K$ και $\psi : K \kindArrow J$
         τέτοιες ώστε $\psi \circ \phi = id$.
        \end{definition}

        \newtheorem{proposition}{Πρόταση}
        \begin{proposition}
        \label{prop:retracts-fixed-points}
        Έστω $J$ συρρίκνωση του $K$ και $\fixo_K$ ένας fixpoint τελεστής στο $K$.
        Τότε υπάρχει fixpoint τελεστής $\fixo_J$ στο $J$.
        \end{proposition}

        \newtheorem{proof}{Απόδειξη}
        \begin{proof}
        Αρκεί να πάρουμε $\fixo_J(f) = \psi (\fixo_K (\phi \circ f \circ \psi))$.
        \end{proof}

        \begin{proposition}{Πρόταση 2}
        \label{prop:kind-structure}
        Έστω $K$ ένα kind της \FOMF{}. Τότε υπάρχει μοναδική (πιθανώς κενή) ακολουθία από
         kinds $(K_0, \dots, K_n)$  τέτοια ώστε $K = \seq{K} \kindArrow \Type$.
        \end{proposition}
        \begin{proof}
		Από επαγωγή στην κατασκευή των kinds.
        \end{proof}

        \begin{proposition}
   Κάθε kind $K$ στην \FOMF{}, είναι συρρίκνση $(K \kindArrow \Type)
  \kindArrow \Type$.
  \end{proposition}
  \begin{proof}
  Έστω $K = \seq{K} \kindArrow \Type$ (από \textbf{\textit{Πρόταση 2}}), και αρκεί να πάρουμε:
  \begin{align*}
  \phi &: K \kindArrow (K \kindArrow \Type) \kindArrow \Type \\
    \phi &= \lambda (x :: K) . \lambda (f :: K \kindArrow \Type) . f x\\
    \psi &: ((K \kindArrow \Type) \kindArrow \Type) \kindArrow K\\
    \psi &= \lambda (w :: (K \kindArrow \Type) \kindArrow \Type) . \lambda (\seq{a :: K}) . w (\lambda o :: K . o\ \seq{a})\\
    \end{align*}
    \end{proof}

    \newtheorem{corollary}{Λήμμα}
    \begin{corollary}
    Αν υπάρχει fixpoint τελεστής στο kind $(K \kindArrow \Type) \kindArrow \Type$, τότε υπάρχει
    και για κάθε $K$
    \end{corollary}


Τέλος, η απόδειξη ολοκληρώνεται αν αντικαταστήσουμε το $K$ στον ορισμό του $\ifix$ με
$K \kindArrow \Type$ για να πάρουμε σταθερό σημείο στο kind $(K \kindArrow \Type) \kindArrow \Type$,
που από το τελευταίο λήμμα αρκεί να μας δώσει fixpoint σε κάθε $K$.



Η παραπάνω απόδειξη στηρίζεται στην πρόταση \ref{prop:kind-structure},
επομένως δεν αληθεύει για αυθαίρετα kinds. Η \FOMF{} που θα εξετάσουμε
υποστηρίζει μόνο kinds που κατασκευάζονται από τα $\kindArrow$ και $\Type$,
και είναι αληθής στην περίπτωσή μας.

Το γεγονός ότι οι συρρικνώσεις διατηρούν την ιδιότητα του σταθερού σημείου είναι γνωστό στον
τομέα της αλγεβρικής τοπολογίας \cite{eilenberg-steenrod}. Αυτός είναι και ο λόγος που στις διατυπώσεις
των παραπάνω ορισμών και θεωρημάτων δεν γίνεται ιδιαίτερη αναφορά στην φύση των kinds, καθώς
ισχύουν σε αρκετά γενικευμένο περιβάλλον στην θεωρία κατηγοριών, που εμπεριέχει προφανώς την
δομή των kinds που εξετάζουμε.

Η έννοια της συρρίκνωσης στην μελέτη των τύπων δεδομένων είναι γνωστό εργαλείο στην θεωρητική
επιστήμη υπολογιστών, για παράδειγμα
 \cite{stirling}, αλλά δεν έχουμε βρει εκδοχή της πρότασης \ref{prop:retracts-fixed-points} στην βιβλιογραφία.

Η παραπάνω απόδειξη παρουσιάστηκε στο πλαίσιο της εργασίας μας από τον Chad Nester.
